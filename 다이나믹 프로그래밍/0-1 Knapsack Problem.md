# 💡 0-1 배낭 문제(Knapsack Problem)
- 0-1 배낭 문제는 다이나믹 프로그래밍으로 효율적으로 해결할 수 있는 고전적인 최적화 문제입니다.
- 문제의 정의는 다음과 같습니다:
  - 주어진 무게 한도 내에서 물건들의 가치의 합을 최대화하려고 합니다.
  - 각 물건은 무게 w[i]와 가치 v[i]를 가지고 있습니다.
  - 배낭의 최대 무게는 W 입니다.

### 📍 DP로 해결하는 방법

1. **정의**: `dp[i][j]`를 __"첫 i개의 물건들 중에서 무게 j 이하의 배낭에 넣을 수 있는 최대 가치"__ 라고 정의합니다.
2. **초기화**: `dp[0][j]`는 0입니다. (첫 0개의 물건들은 아무것도 선택할 수 없기 때문)
3. **점화식**:
   - 물건 i를 선택하지 않는 경우: dp[i][j] = dp[i-1][j]
   - 물건 i를 선택하는 경우 (만약 j의 무게에서 물건 i의 무게를 뺀 값이 0 이상이라면): dp[i][j] = dp[i-1][j-w[i]] + v[i]
   - 따라서, dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) (j의 무게에서 물건 i의 무게를 뺀 값이 0 이상인 경우에만 고려)
4. **결과**: `dp[n][W]`가 최대 가치를 나타냅니다. 여기서 n은 물건의 수입니다.

▶️ 이 점화식을 사용하여 모든 가능한 무게에 대해 계산을 반복하면, `dp[n][W]`에서 최대 가치를 얻을 수 있습니다.

### 📍 자바 코드 구현 

```java
public int knapsack(int W, int[] wt, int[] val, int n) {
    int[][] dp = new int[n+1][W+1];
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            if (i == 0 || j == 0)
                dp[i][j] = 0;
            else if (wt[i-1] <= j)
                dp[i][j] = Math.max(val[i-1] + dp[i-1][j-wt[i-1]], dp[i-1][j]);
            else
                dp[i][j] = dp[i-1][j];
        }
    }
    
    return dp[n][W];
}
```

- 여기서 `wt`는 각 물건의 무게를 나타내는 배열이고, `val`은 각 물건의 가치를 나타내는 배열입니다. `n`은 물건의 수입니다.

## 📌 example
**물건들**:
1. 무게 10, 가치 60
2. 무게 20, 가치 100
3. 무게 30, 가치 120

배낭의 최대 무게는 ```50```입니다.

**DP 테이블 생성**
- 먼저, dp[i][j]는 "첫 i개의 물건들 중에서 무게 j 이하의 배낭에 넣을 수 있는 최대 가치"로 정의합니다.
```plaintext
(i: 물건 번호, j: 배낭의 무게)
      0    10   20   30   40   50
----------------------------------
0 |   0    0    0    0    0    0
1 |   0   60   60   60   60   60
2 |   0   60  100  160  160  160
3 |   0   60  100  160  220  280
```

**해설**:
- `i=0`: 아무 물건도 선택하지 않은 경우로, 모든 배낭의 가치는 0입니다.
  
- `i=1` (1번 물건<무게 10, 가치 60>까지 고려할 때):
  - `j=0`: 무게 제한이 0이므로 아무 물건도 넣을 수 없습니다.
  - `j=10`: 1번 물건을 넣을 수 있으므로 가치는 60입니다.
  - `j=20` ~ `j=50`: 아직 2번 물건과 3번 물건은 고려하지 않았으므로 모든 가치는 60입니다.
  
- `i=2` (2번 물건<무게 20, 가치 100>까지 고려할 때):
  - `j=10`: 2번 물건은 넣을 수 없으므로 1번 물건만 고려한 상태와 동일합니다.
  - `j=20`: 2번 물건만 넣을 경우의 가치는 100입니다.
  - `j=30`: 1번 물건과 2번 물건을 모두 넣을 경우의 가치는 60 + 100 = 160입니다.
  - `j=40`, `j=50`: 아직 3번 물건은 고려하지 않았으므로 가치는 160입니다.
  
- `i=3` (3번 물건<무게 30, 가치 120>까지 고려할 때):
  - `j=10`, `j=20`: 3번 물건은 넣을 수 없으므로 2번 물건까지 고려한 상태와 동일합니다.
  - `j=30`: 3번 물건만 넣을 경우의 가치는 120입니다. 하지만 1번 물건과 2번 물건을 모두 넣는 경우가 더 높은 가치(160)를 가집니다.
  - `j=40`: 3번 물건과 1번 물건을 넣을 경우의 가치는 120 + 60 = 180입니다. 하지만 2번 물건과 1번 물건을 모두 넣는 경우가 더 높은 가치(220)를 가집니다.
  - `j=50`: 1번, 2번, 3번 물건을 모두 넣을 경우의 가치는 60 + 100 + 120 = 280입니다.

▶️ 따라서 배낭의 최대 무게가 50일 때 얻을 수 있는 최대 가치는 280입니다.
