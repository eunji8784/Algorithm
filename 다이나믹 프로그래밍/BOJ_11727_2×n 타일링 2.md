# 💡 풀이 
```
1. 마지막에 2 x 1 타일을 1개 배치하는 경우: dp[n - 1]
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ
|      n - 1      | 1 |
|                 |   |
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ

2. 마지막에 1 x 2 타일을 2개 배치하는 경우: dp[n - 2]
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ
|      n - 2    |  2  |
|               |- - -|
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ

3. 마지막에 2 x 2 타일을 1개 배치하는 경우: dp[n - 2]
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ
|      n - 2    |  2  |
|               |     |
 ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ ㅡ                  
```

따라서 dp[n] = dp[n - 1] + 2 * dp[n - 2] 라는 점화식을 도출할 수 있습니다.

## 📌 주의
1. 모듈로 연산이 각각의 중간 계산마다 적용 (O)
```java
if (n > 1) {
  dp[2] = 3;
  for (int i = 3; i <= n; i++) {
				dp[i] = (dp[i - 1] + 2 * dp[i - 2]) % 10007;
  }
}

System.out.println(dp[n]);
```
2. 최종 결과에서만 모듈로 연산이 적용 (X)
```java
if (n > 1) {
  dp[2] = 3;
  for (int i = 3; i <= n; i++) {
    dp[i] = (dp[i - 1] + 2 * dp[i - 2]);
  }
}

System.out.println(dp[n] % 10007);
```

▶️ 2번의 경우 큰 수에 대한 연산이 발생할 경우, int의 범위를 초과하는 문제가 발생할 수 있습니다. 즉, 중간 계산 과정에서 발생하는 큰 수가 int의 최대값을 초과하면 ```오버플로우```가 발생하여 잘못된 결과가 나옵니다.
첫 번째 코드는 각 단계에서 모듈로 연산을 적용하므로 이러한 오버플로우 문제가 발생하지 않습니다. 반면, 두 번째 코드는 모든 계산이 완료된 후에 모듈로 연산을 적용하기 때문에 중간에 int의 범위를 초과하는 값을 가질 수 있고, 그로 인해 최종 결과가 잘못될 수 있습니다.

따라서, ```모듈로 연산이 필요한 문제에서는 중간 계산마다 모듈로 연산을 적용하여 오버플로우를 방지```하는 것이 좋습니다.
