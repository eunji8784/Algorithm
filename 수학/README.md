# 💡 소수 찾기
- __소수(Prime number):__ 1과 자신 외에 어떤 정수로도 나누어 떨어지지 않는 1보다 큰 정수
## 📌 자연수 n에 대한 소수 판별 방법
1. 주어진 수 n이 1이라면 소수가 아니다.
2. 2부터 √n까지의 수로 n을 나누어 보면서 나누어 떨어지는 수가 있는지 확인한다.
3. 나누어 떨어지는 수가 있다면 n은 소수가 아니다. 없다면 n은 소수이다.

[소수 판별 코드](BOJ_1978_소수%20찾기.java)

### ❓ n의 제곱근까지만 확인하는 이유
- 소수 판별을 위해 주어진 수 n의 제곱근까지만 확인하는 이유는 ```시간 복잡도```를 줄이기 위함이며, 그 이상의 수를 확인할 필요가 없기 때문.
```
1. 만약 어떤 수 n이 소수가 아니라면, n = a x b 형태로 표현될 수 있다. (여기서 a와 b는 1과 n을 제외한 어떤 정수이다.)

2. a와 b둘 다 n의 제곱근보다 크다면, 그들의 곱 a x b는 n을 초과하게 된다. 

3. 반대로 a와 b 둘 다 n의 제곱근보다 작다면, 그들의 곱 a x b는 n보다 작아진다.

4. 따라서, a와 b 중 하나는 반드시 n의 제곱근 이하이며, 다른 하나는 n의 제곱근 이상이어야 한다.

5. 그러므로, 소수 판별을 할 때 n의 제곱근까지만 확인하면 그 이후의 수를 확인할 필요가 없다. 만약 n의 제곱근 이하의 어떤 수로도 n을 나눌 수 없다면, n은 소수이다.
```
▶️ 이러한 접근법을 통해, 소수 판별 알고리즘의 시간 복잡도를 O(n)에서 __O(√n)__ 로 줄일 수 있다.

---

# 💡 소인수분해
- 어떤 수를 소수의 곱으로만 나타내는 것.
- ex) 12 = 2 x 2 x 3

## 📌 자연수 n에 대한 소인수분해 방법
1. i = 2부터 시작
2. N을 i로 나눌 수 있다면, N은 i의 배수이다. 
   - 이 경우 i를 출력하고, N을 i로 나눈 몫을 다시 N으로 설정
   - N이 i로 나누어 떨어지지 않을 때까지 이 과정을 계속 반복
3. N을 i로 나눌 수 없다면 i를 1 증가시키고 다시 2번 과정을 진행
4. i x i <= N일 동안 2번과 3번 과정을 반복 
5. 위 과정들을 거친 후 N > 1이라면, N도 소수이므로 출력

[소인수분해 코드](BOJ_11653_소인수분해.java)

```
📍 
어떤 수 N의 소인수를 찾기 위해서는 그 수의 제곱근까지만 검사하면 된다.
제곱근 이상의 수로 나누어 떨어진다면 그 수의 짝꿍인 수가 제곱근 이하에서 이미 나누어져서 발견될 것이기 때문이다.
예를 들어, 28의 제곱근은 대략 5.3이므로 2에서 5까지만 나누어보면 된다.
```
---
# 💡 에라토스테네스의 체
- ```소수를 구하는 알고리즘``` 중 하나.
- 그리스 수학자 에라토스테네스가 고안함.
- 에라토스테네스의 체를 이용해 __특정한 숫자 범위 내의 모든 소수__ 를 찾아낼 수 있음.
- 시간 복잡도가 ![에라토스테네스의 체 시간복잡도](https://latex.codecogs.com/png.latex?O(n%20\log%20\log%20n))
으로, 주어진 범위 내의 모든 소수를 빠르게 찾아낼 수 있음.

## 📌 에라토스테네스의 체의 기본 원리

1. 2부터 n까지의 숫자를 나열한다.
2. 처음 나열된 숫자 2를 소수로 간주하고, 2의 배수를 모두 지운다.
3. 남아 있는 숫자들 중에서 가장 작은 수인 3을 소수로 간주하고, 3의 배수를 모두 지운다.
4. 다시 남아 있는 숫자들 중에서 가장 작은 수를 소수로 간주하고, 그 수의 배수를 모두 지운다. 
5. 이 과정을 반복하여 n 까지 갈 때까지 소수를 판별한다.

### (예제)
- n = 10인 경우, 2부터 10까지의 숫자를 나열한다.
- 2는 소수이므로 2의 배수인 4, 6, 8, 10을 지운다.
- 다음 숫자인 3은 소수이므로 3의 배수인 6, 9를 지운다. (6은 이미 지워진 상태)
- 4는 이미 지워진 상태이므로 건너뛰고, 5는 소수이므로 5의 배수인 10을 지운다. (10은 이미 지워진 상태)
- 6, 7, 8, 9, 10 모두 지워진 상태이거나 소수인 상태로 남게 되고, 최종적으로 2, 3, 5, 7이 소수로 남는다.
---
# 💡 모듈러 연산 (modular arithmetic)
- 나머지 연산을 의미
- 수학적으로, a를 m으로 나누었을 때의 나머지를 a mod m 또는 a % m 으로 표현. ex) 17 mod 5 = 2
- 컴퓨터 과학과 암호학에서는 큰 수의 연산을 다룰 때 오버플로우를 방지하거나, 특정 범위 내에서 값을 유지하려고 할 때 모듈러 연산을 사용

## 📌 모듈러 연산의 특성

1. **덧셈에 대한 모듈로 연산의 분배법칙**:
   - (a + b) mod m = (a mod m + b mod m) mod m

2. **곱셈에 대한 모듈로 연산의 분배법칙**: 
   - (a x b) mod m = (a mod m x b mod m) mod m
     
3. **거듭제곱에 대한 모듈로 연산의 분배법칙**:
   - a^b mod m = ((a mod m)^b) mod m

4. **나머지는 항상 양수 또는 0**:
   - a mod m 의 결과는 항상 0 이상 m 미만의 정수

---

# 💡 유클리드 호제법(Euclidean Algorithm)
- 두 양의 정수의 __최대공약수(Greatest Common Divisor, GCD)__ 를 구하는 알고리즘.
- 이 알고리즘은 다음의 원리에 기반한다:
   - ```두 수 a와 b (a > b)의 최대공약수는 'b'와 'a를 b로 나눈 나머지'의 최대공약수와 같다.```
- 이 원리를 이용하여 반복적으로 나눗셈을 수행하다 보면, 어느 순간 나머지가 0이 된다. 그 때의 나누는 수가 최대공약수가 된다.
- 이 유클리드 호제법은 매우 효율적으로 GCD를 구할 수 있어서 널리 사용된다.

## 📌 유클리드 호제법의 절차

1. 두 수 a와 b에서 a가 b보다 크다고 가정한다.
2. a를 b로 나눈 나머지를 r이라고 한다.
3. 만약 r이 0이라면, b가 a와 b의 최대공약수(GCD)이다.
4. r이 0이 아니라면, a에 b의 값을 할당하고, b에는 r의 값을 할당한 뒤, 다시 2번부터 반복한다.

### 예시

GCD(56, 98)를 구하는 경우:

1. 56을 98로 나눈 나머지는 56.
2. 98을 56으로 나눈 나머지는 42.
3. 56을 42로 나눈 나머지는 14.
4. 42를 14로 나눈 나머지는 0. 따라서, 14가 56과 98의 최대공약수(GCD).

### ✏️ 코드

```java
public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
```

---

# 💡 파스칼의 삼각형
- __수학에서 조합론적인 특징을 가진 삼각형 형태의 수 배열.__
- 각 숫자는 ```바로 위의 두 숫자의 합```으로 구성된다.
- 다양한 수학적 문제나 식에서 유용하게 사용된다. ex) 이항 정리에서의 계수 찾기 

```
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
  ...........
```

## 📌 파스칼의 삼각형의 특성

1. **각 행의 첫 번째와 마지막 숫자는 항상 1이다.**
2. 삼각형의 n번째 행과 k번째 열(0-based index)의 수는 "n-1개 중에서 k-1개를 선택하는 방법의 수"와 동일하며, 조합으로 표시하면 n-1Ck-1이다.
3. n번째 행의 수의 합은 2^{n-1}이다.

---

# 💡 이항 계수 (Binomial Coefficient)

- 주어진 크기의 집합에서 일부 원소를 선택하는 방법의 수.
- 기호로는 nCk로 나타내며, 이는 ```n개 중에서 k개를 선택하는 방법의 수```로 해석된다.

수학적으로, 이항 계수는 다음과 같은 공식으로 정의된다:

$$
\binom{n}{k} = \frac{n!}{k!(n-k)!}
$$

이때, n!는 n의 팩토리얼을 의미하며, n! = n x (n-1) x ... x 2 x 1 이다.

## 📌 이항 계수와 파스칼의 삼각형 

```
        0C0
      1C0 1C1
    2C0 2C1 2C2
  3C0 3C1 3C2 3C3
4C0 4C1 4C2 4C3 4C4
       ... ...
```
파스칼의 삼각형에서의 각 항은 그 항 바로 위와 바로 위의 왼쪽 항을 더한 것과 같다. 이 특성을 사용하여 이항 계수의 점화식을 나타낼 수 있다:

$$
\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}
$$

### 📍 이항 계수 계산 방법
1. 파스칼의 삼각형의 첫 번째 행과 첫 번째 열은 모두 1로 초기화한다.
2. 주어진 n과 k에 대해 nCk의 값을 계산하려면 다음과 같은 절차를 따른다.
   - 파스칼의 삼각형을 n번째 행까지 확장한다.
   - 각 항의 값을 계산할 때 위의 점화식을 사용한다.
   - 계산이 끝나면 nCk의 값을 읽는다.
  
### ✏️ 코드
```java
public void printPascalsTriangle(int n, int k) {
    int[][] triangle = new int[n + 1][n + 1];

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            if (j == 0 || j == i) {
                triangle[i][j] = 1;
            } else {
                triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j];
            }
        }
    }

   System.out.print(triangle[n][k]);
}
```
